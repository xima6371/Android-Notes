---
title: 垃圾收集GC
date: 2019-04-01 22:29:55
tags: GC
categories: JVM
---



本文介绍垃圾回收的以下方面

1. 何要GC

2. 那些要回收

3. 如何进行回收

<!-- more -->

#### 为什么要GC

每个Java程序分配的内存是有限的，当需要的内存超过分配的内存，会导致内存溢出，内存泄露等问题。

因此我们需要释放一些不必要的资源，来维持程序的正常运行。



#### 哪些内存需要回收

程序计数器，虚拟机栈，本地方法栈是线程私有的，线程执行完毕就GG了。其内存分配和回收在编译期就可确定，一般不考虑这些区域的回收问题。

因此一般回收的是堆中，方法区中的内存。



##### 判断内存是否需要回收

一般来说，对象没有在任何地方被引用时，就说明这个对象已死，需要被回收。判断对象存活的算法有两种：引用计数算法，可达性分析算法。

1. 引用计数算法

   > 每个对象都有一个引用次数计数器，当有地方引用该对象时计数+1，引用失效时则-1
   >
   > 为0时说明对象已死，需要被回收
   >
   > 缺点：无法处理相互循环引用的问题(两对象相互引用，但是两对象都为null，但是计数器不为0)

2. 可达性分析算法

   * GC roots对象包括
     * 虚拟机栈本地变量表中引用的对象
     * 本地方法栈Native方法中引用的对象
     * 方法区中的常量引用的对象，静态引用的对象

   > 使用GC roots对象作为根节点，当有对象与roots之间有引用关系时，建立引用链连接双方。
   >
   > 对象通过引用链来查询是否有roots，若无则说明引用可回收。

   

   * 回收策略

        ​        对象查询不到roots时，不会立即回收，而是对其进行第一次标记与筛选是否要执行finalize()方法。

        筛选掉那些没有覆写finalize()方法或者已经调用过finalize()方法的对象。

        筛选后，对象会被放置到F-Queue队列中，再由一个低优先级的线程去执行finalize()方法。

        若在finalize()中，对象重新与roots建立引用链关系，则不会被回收。

   

   * 缺点

   > 由于线程优先级低，很有可能对象已经被回收了还没执行finalize()方法。
   >
   > 低优先级的原因是为了避免因finalize()方法过于耗时，导致F-Queue中的其他对象永久处于等待，最后引起内存回收崩溃。

   

   * Tips

     由于finalize()运行代价高，不确定性大(在低优先级线程中运行)，一般通过try-finally替代。

     

   ##### 方法区回收

   1. 废弃常量

      常量池中字符若没有任何对象引用他，则成为废弃常量。

   2. 无用的类

      - 该类所有实例被回收
      - 加载该类的ClassLoader被回收
      - 对应的java.lang.Class对象没有被引用，无法通过反射访问该类方法

      满足上述条件就可以回收类，但不是必须回收。

   

   ##### 垃圾收集算法

   1. 标记-清除算法

      - 标记，清除效率不高
      - 清除后可能产生大量空间碎片，导致缺少连续的大内存空间

      

   2. 复制算法

      内存分为两块，每次使用一块，进行清理时，讲存活的对象复制到空闲的内存块中，另一块执行完全清理。

      - 实现简单，运行高效
      - 不适合对象存活率高的情况(大量复制会降低效率)

      商用一般将方法区内存空间分为8：1：1，其中9份用于日常使用，当清理过后，将存活的对象复制到剩下的1份中。

      当这份空间不足以容纳存活对象时，则需要向其他内存(堆的老年代，新生代)进行借用。

      

   3. 标记-整理算法

      跟标记-清除类似，不同的是，回收时，存活对象向一端移动，同时清除端边界之外的内存，最后使得内存空间连续。

      

   4. 分代收集算法

      根据对象存活的周期，将堆内存分为新生代，老年代。

      - 新生代：对象存活周期短，选用复制算法
      - 老年代：存活率高，选用标记-清理或整理方法

      

#### Tips

永久代-->方法区。

堆包括方法区。

堆分为新生代和老年代和永久代。

   

   

   

   

   

   



